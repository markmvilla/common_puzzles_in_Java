//big-o
//logarithms
//triangular series
//33 consecutive duplicates
//1: use count array, O(n) time with O(n) space
//2: use actual_sum - should_be_sum O(n) with O(1) space
//39 two egg problem
//1: this is a triangular series, n/2*(n+1) >= 100
//binary search
//12
//O(lg n)
//13
//recursive binary search O(lg n) time, O(n) space because the call stack and done in-place
//iterative binary search O(lg n) time, O(1) since done in-place and no call stack
public static int rotationSearchDict(String[] dict, int startIndex, int endIndex) {
  //floats get floored "toward" zero so rotation will be midIndex+1
  int midIndex = (startIndex + endIndex) / 2;
  if (startIndex == midIndex) {
   return midIndex + 1;
  } else if (dict[startIndex].compareTo(dict[midIndex]) > 0) {
   return rotationSearchDict(dict, startIndex, midIndex);
  } else {
   return rotationSearchDict(dict, midIndex, endIndex);
  }
 }
 //40
 //1: hashmap search O(n) time, O(n) space
  public static int findDuplicate(int[] nums) {
  HashMap < Integer, Integer > hashmap = new HashMap < > ();
  for (int i = 0; i < nums.length; i++) {
   if (hashmap.containsKey(nums[i])) {
    return nums[i];
   } else {
    hashmap.put(nums[i], 0);
   }
  }
  return -1;
 }
 //2: count array O(n) time, O(n) space
  public static int findDuplicate2(int[] nums) {
   int[] mem = new int[nums.length];
   for (int i = 0; i < nums.length; i++) {
    if (mem[nums[i]] > 0) {
     return nums[i];
    } else {
     mem[nums[i]] += 1;
    }
   }
   return -1;
  }
 //41
 //1: in place tagging. O(n) time, O(1) space. necessary req. include having int values within a range smaller than the array length
 public static int findDuplicate3(int[] arr) {
    // write the body of your function here
    int dup = -1;
    for (int i = 0; i < arr.length; i++) {
        if(arr[Math.abs(arr[i])] >=0)
           arr[Math.abs(arr[i])] *= -1;
        else {
          dup = Math.abs(arr[i]);
          break;
        }
    }
    return dup;
}
//counting sort
//brute force algorithms
//greedy algorithms
//1
//1 : greedily update minvalue and maxprofit. O(n) time, O(1) space.
//2
//1 : maintain a left[] and right[] product for each i. O(n) time O(n) space. return out[] with each left[] * right[]. 
//3
//1 : brute force three loop. O(n^3) time, O(1) space
//1 : scan and combine. O(n) time, O(1) space
public static int triplete(int[] arr) {
        int[] maxThree = new int[3];
        int[] minTwo = new int[2];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > maxThree[0]) {
              maxThree[2] = maxThree[1];
              maxThree[1] = maxThree[0];
              maxThree[0] = arr[i];
            }
            else if (arr[i] > maxThree[1]) {
              maxThree[2] = maxThree[1];
              maxThree[1] = arr[i];
            }
            else if (arr[i] > maxThree[2]) {
              maxThree[2] = arr[i];
            }
            
            if (arr[i] < minTwo[0]) {
              minTwo[1] = minTwo[0];
              minTwo[0] = arr[i];
            }
            else if( arr[i] <minTwo[1]) {
              minTwo[1] = arr[i];
            }
        }
        return Math.max(maxThree[0]*maxThree[1]*maxThree[2], minTwo[0]*minTwo[1]*maxThree[0]);
}
//bottom-up, overlapping subproblems, memoization
//5
//1: dynamicly iterate (bottom-up) through coins and mem array. O(c*n) time, O(n) space.
//   for each index in memArray and each coin, if index >= coin, add combinations of remainder.
public static long change(int change, int[] coins) {
        int[] table = new int[change + 1];
        Arrays.fill(table,0);
        table[0] = 1;
        for (int i=0; i<coins.length; i++)
          for (int j=coins[i]; j<=change; j++)
            table[j] += table[j -coins[i]];
        return table[change];
}
//15
//1: dynamicly iterate (bottom-up)
//16
//short circuit evaluation
//garbage collection
//closure
//17
//18
//array-slicing
//hashing
//11
//30
//32
//34
//42
//mutiable vs immutable
//in-place
//24
//26
//27
//40
