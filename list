//33 consecutive duplicates
//1: use count array, O(n) time with O(n) space
//2: use actual_sum - should_be_sum O(n) with O(1) space
//39 two egg problem
//1: this is a triangular series, n/2*(n+1) >= 100
//12
//O(lg n)
//13
//recursive binary search O(lg n) time, O(n) space because the call stack and done in-place
//iterative binary search O(lg n) time, O(1) since done in-place and no call stack
public static int rotationSearchDict(String[] dict, int startIndex, int endIndex) {
  //floats get floored "toward" zero so rotation will be midIndex+1
  int midIndex = (startIndex + endIndex) / 2;
  if (startIndex == midIndex) {
   return midIndex + 1;
  } else if (dict[startIndex].compareTo(dict[midIndex]) > 0) {
   return rotationSearchDict(dict, startIndex, midIndex);
  } else {
   return rotationSearchDict(dict, midIndex, endIndex);
  }
 }
 //40
 //1: hashmap search O(n) time, O(n) space
  public static int findDuplicate(int[] nums) {
  HashMap < Integer, Integer > hashmap = new HashMap < > ();
  for (int i = 0; i < nums.length; i++) {
   if (hashmap.containsKey(nums[i])) {
    return nums[i];
   } else {
    hashmap.put(nums[i], 0);
   }
  }
  return -1;
 }
 //2: count array O(n) time, O(n) space
  public static int findDuplicate2(int[] nums) {
   int[] mem = new int[nums.length];
   for (int i = 0; i < nums.length; i++) {
    if (mem[nums[i]] > 0) {
     return nums[i];
    } else {
     mem[nums[i]] += 1;
    }
   }
   return -1;
  }
 //3: in place tagging. O(n) time, O(1) space. necessary req. include having int values within a range smaller than the array length
 public static int findDuplicate3(int[] arr) {
    // write the body of your function here
    int dup = -1;
    for (int i = 0; i < arr.length; i++) {
        if(arr[Math.abs(arr[i])] >=0)
           arr[Math.abs(arr[i])] *= -1;
        else {
          dup = Math.abs(arr[i]);
          break;
        }
    }
    return dup;
}
//1
//1 : greedily update minvalue and maxprofit. O(n) time, O(1) space.
//2
//1 : maintain a left[] and right[] product for each i. O(n) time O(n) space. return out[] with each left[] * right[]. 
//3
//1 : greed select. sort,greedily find highest 3 and check for even number of negative.
